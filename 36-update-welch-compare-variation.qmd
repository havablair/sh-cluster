# Welch ANOVA - compare variation explained

## Overview

This chapter is similar to 28 (compare variation demo), but here am using Welch ANOVA followed by calculation of epsilon squared as an effect size (which we can do because `{effectsize}` uses the F stats from the Welch's ANOVA to estimate epsilon squared).

The goal is to use selected soil health indicators from the CIG dataset to compare the amount of variation explained when grouping the data by MLRA vs. taxonomy vs. soil health group +climate cluster (generated by k-means clustering on soils and climate data separately).

## Models

Response variables: soil health indicators (perhaps the NRCS tech note list?).
Should we use just 1 year of data to avoid pulling in year-to-year variability?
Could choose 2019, because this is the year for which we have PLFA data, and PLFA is on the NRCS list.

Variables from the NRCS Soil Health Tech Note recommended methods:

-   Aggregate stability
-   PMC
-   POXC
-   (skip - weird thing with RRV poor extraction in CIG data) ACE Protein
-   PLFA

```{r setup}

library(tidyverse)
library(glue)
library(ggbeeswarm)
library(lmerTest)
library(rstatix)
library(gt)
library(performance)
library(openxlsx)
```

## Data

As part of the validation process for my k-means analysis, I determined the soil health group assigned to each CIG sampling area at the mapunit level (hillslope within management condition).

This file has MUKEYs associated with the CIG and NCSS validation points: `cig_ncss_validation_pt_mukey_sample_id.csv`

And this file has the MUKEYs assocaited wit the SHI points: `data/validation_data/NRCS-SHI/shi_site_pca_validation_points.csv`

```{r}

# this has climate clusters by mukey, need to join with the other validation data
clim_mukeys <- read_csv("data/mukey_cluster_assignments_and_props_climate_only.csv") %>% 
  rename_with(.fn = ~str_replace(.x, "k_", "clim_k_"), .cols = contains("k_")) %>% 
  select(mukey, contains("clim_k_"))

```

### Load data

```{r data}
#| message: false
#| warning: false

# this file created in "extract_raster_values_at_validation_points.R"
# it is at the "sample" level. There are often multiple rows
# per CIG sample because many of the map units that contain these 
# sample points have multiple components included in the analysis. 
cig_comps <- read_csv("data/cig_incl_components_table.csv") %>% 
  # for now, just using 2019 data so we avoid the year-to-year variability we
  # know is there, and b/c we have PLFA data for 2019 only
  filter(sample_id %in% c(1:243))


# this is for disambiguating which MUKEY should be assigned
# to each CIG val_unit_id (mapunit), because sometimes the
# GPS points landed in multiple mapunits
# the code that handles this is in "extract_raster_values_at_validation_points.R
cig_mukey_votes <- read_csv("data/cig_mukey_votes_for_validation.csv") 

# cluster assigned to each CIG point. this dataset is created in "prep_validation_data_for_pca_version.R"
# it is at the "validation unit" level (summarized to hillslope within management)
cig_clus <- read_csv("data/validation_data_pca_clusters_and_soil_props.csv") %>% 
  filter(str_detect(val_unit_id, "CV") |
           str_detect(val_unit_id, "SH") |
         str_detect(val_unit_id, "UD")) %>%
  mutate(region = str_extract(val_unit_id, "[:alpha:]{2}"),
         soil_group = glue("grp-{k_8}")) %>% 
  select(val_unit_id, soil_group, k_8, region)

# currently from csv saved by "heatmap_validation_counties.R", 
# but need to move this to a more logical place 
cig_mlras <- read_csv("data/cig_mlra_by_val_unit_id.csv") 

cig_val <- left_join(cig_clus, cig_mlras, by = "val_unit_id") %>%
  # need to fix this NA created by the join, it happened
  # because this RR4-CV site had a label change from A to B
  # during the harmonization I did to align soil textures
  mutate(
    MLRA_NAME = case_when(
      val_unit_id == "RR4-CV-B" ~ "Red River Valley of the North",
      TRUE ~ MLRA_NAME
    ),
    mlra_short = case_when(
      str_detect(MLRA_NAME, "Eastern Iowa") ~ "E IA MN Till",
      str_detect(MLRA_NAME, "Red River") ~ "Red River",
      str_detect(MLRA_NAME, "Rolling Till Prairie") ~ "Rol Till Pr",
      str_detect(MLRA_NAME, "Central Min") ~ "C MN Sandy",
      str_detect(MLRA_NAME, "Gray Drift") ~ "N MN Gray",
      str_detect(MLRA_NAME, "Central Iowa") ~ "C IA MN Till",
      TRUE ~ "Fix me"
    )
  )

# want all the CIG lab observations (not averaged to the plot level)
lab <- read_csv("data/cig_lab_data_all_20230301.csv") %>%
  mutate(val_unit_id = glue("{site}-{treatment}-{position}")) %>%
  select(
    sample_id,
    val_unit_id,
    region,
    position,
    corr_percent_stable_gr2mm,
    ugC_g_day,
    BG_activity,
    NAG_activity,
    P_activity,
    poxc_mg_kg,
    mean_protein_mg_g,
    org_c_wt_percent, # added per reviewer 1 comment
    mbc_ug_g_soil,
    mbn_ug_g_soil,
    total_living_microbial_biomass_plfa_ng_g,
    total_bacteria_plfa_ng_g,
    total_fungi_plfa_ng_g,
    total_bacteria_percent_of_tot_biomass,
    total_fungi_percent_of_tot_biomass
  ) %>% 
  filter(sample_id %in% c(1:243))

# missing data due to sample contamination in 2019 samples
# that were run for PLFA. Pulling MBN values from 2020
# for this validation site only after confirming that the values 
# are in a similar range for this soil type, hillslope position,
# and region
mbn_mw4_cva <-
  read_csv("data/cig_lab_data_all_20230301.csv") %>%
  mutate(val_unit_id = glue("{site}-{treatment}-{position}")) %>%
  filter(sample_id %in% c(474:476)) %>%
  pull(mbn_ug_g_soil) %>%
  mean(., na.rm = TRUE)



```

### Summarize to mapunit level

Recall that the lab data and the component data need to be summarized to the "mapunit" level.
This involves averaging the soil properties and determining the majority taxonomic classification for each MUKEY based on the included components (recall that most MUKEYs have just 1 contributing component, so we just need to account for those that have \>1 contributing component to determine, for each level of taxonomy I look at, what the majority assignment should be).

Starting with the taxonomy data:

```{r}
# how many unique mukeys are we working with?
(cig_mukeys <- cig_comps %>%
    pull(mukey) %>%
    unique() %>%
    length())

# Q: which mukeys have multiple components contributing data?
# A: 16 unique mukeys
cig_comps %>% 
  select(mukey, cokey, taxclname:taxpartsize) %>% 
  distinct() %>% 
  group_by(mukey) %>% 
  count() %>% 
  filter(n>1)

# goal: assign each mukey a representative suborder
# based on the suborders of the components within it.
# should get back object w/ length 37 (# of unique mukeys)
cig_comps %>% 
  select(mukey, cokey, comppct_r, taxsuborder) %>% 
  distinct() %>% 
  group_by(mukey, taxsuborder) %>% 
  summarise(tot_percent = sum(comppct_r), .groups = "drop") %>% 
  group_by(mukey) %>% 
  slice_max(tot_percent)


```

Function for determining representative taxonomic level .
Using similar code to the example with suborder above, this function allows me to summarize the representative taxonomic level (order, suborder, etc.) based on % area.

```{r}
# calculate representative taxonomy
calc_rep_tax <- function(tax_level, comp_df){
  
  comp_df %>% 
  select(mukey, cokey, comppct_r, {{tax_level}}) %>% 
  distinct() %>% 
  group_by(mukey, {{tax_level}}) %>% 
  summarise(tot_percent = sum(comppct_r), .groups = "drop") %>% 
  group_by(mukey) %>% 
  slice_max(tot_percent) %>% 
    select(-tot_percent)
  
}


order <- calc_rep_tax(taxorder, cig_comps)
suborder <- calc_rep_tax(taxsuborder, cig_comps)
grt_grp <- calc_rep_tax(taxgrtgroup, cig_comps)
sub_grp <- calc_rep_tax(taxsubgrp, cig_comps)
family <- calc_rep_tax(taxclname, cig_comps)

tax_joined <- list(order, suborder, grt_grp, sub_grp, family) %>% 
  purrr::reduce(., left_join, by = "mukey")

tax_val_key <- cig_comps %>% 
  select(val_unit_id, mukey) %>% 
  distinct()

```

Now time to summarize the lab data to the mapunit level, this is easier than the taxonomy because we can just take the average.
Recall that we are working with 2019 data only.

```{r}

lab_summary <- lab %>% 
  select(-sample_id) %>% 
  group_by(val_unit_id) %>% 
  summarise(across(where(is.numeric),
                   ~mean(.x, na.rm = TRUE)))
```

### Join taxonomic and lab info with validation dataset

Here, we create a dataset with one row for each validation unit in the CIG dataset.
It includes information about representative taxonomic classification at different levels (order, suborder, great group) and also representative values for the soil health indicators we want to analyze further below when comparing variance explained by different stratification options (region, taxonomy, k-means group).

```{r}


val_mukey <- left_join(cig_val, cig_mukey_votes, by = "val_unit_id") %>% 
  select(-c(n, max_vote))

val_mukey_lab <- left_join(val_mukey, lab_summary, by = "val_unit_id")

val_all <- left_join(val_mukey_lab, tax_joined, by = "mukey") %>%
 # on list from old key, this id no longer exists
   filter(val_unit_id != "RR4-CV-B") %>% 
  mutate(mbn_ug_g_soil = case_when(
    # dealing with missing data, see note at end of 
    # "load data" code block
    val_unit_id == "MW4-CV-A" ~ mbn_mw4_cva,
    TRUE ~ mbn_ug_g_soil
  ))


val_all_clim <- left_join(val_all, clim_mukeys, by = "mukey") %>% 
  mutate(clim_k_3 = case_when(
    clim_k_3 == "Cluster_1" ~ "Northwest",
    clim_k_3 == "Cluster_2" ~ "Central",
    clim_k_3 == "Cluster_3" ~ "Southeast"
  ))


```

## Response variables - exploratory plots

```{r}

rvars <- c("corr_percent_stable_gr2mm",
           "org_c_wt_percent",
               "ugC_g_day",
               "poxc_mg_kg",
               "mbc_ug_g_soil",
               "mbn_ug_g_soil", # include MBN?
               "total_living_microbial_biomass_plfa_ng_g",
               "total_bacteria_plfa_ng_g",
               "total_fungi_plfa_ng_g"
)


val_long <- val_all %>% 
  select(val_unit_id, all_of(rvars)) %>% 
  pivot_longer(-val_unit_id) %>% 
  mutate( name = case_when(
    name == "corr_percent_stable_gr2mm" ~ "agg_stab",
    name == "ugC_g_day" ~ "pmc_ugCgday",
    name == "total_living_microbial_biomass_plfa_ng_g" ~ "PLFA total",
    name == "total_bacteria_plfa_ng_g" ~ "PLFA bacteria",
    name == "total_fungi_plfa_ng_g" ~ "PLFA fungi",
    name == "org_c_wt_percent" ~ "SOC",
    TRUE ~ name
    
  ))

val_long %>% 
  ggplot() + 
  geom_histogram(aes(value), bins = 20) +
  facet_wrap(vars(name), scales = "free") +
  ggtitle("Distribution (not transformed)")

val_all_clim %>% 
  select(val_unit_id, contains("percent_of")) %>% 
  pivot_longer(-val_unit_id) %>% 
  ggplot() +
  geom_histogram(aes(value), bins = 20) + 
  facet_wrap(vars(name))

val_all_clim %>% 
  select(val_unit_id, contains("percent_of")) %>% 
  pivot_longer(-val_unit_id) %>% 
  group_by(name) %>% 
  summarise(min = min(value), 
            max = max(value))
```

## Stratification options

We could stratify the CIG points based on several different levels of Soil Taxonomy.
How do the CIG sampling points break down in terms of number per cluster, and number per taxonomic level(s) (order, suborder, etc)?

For k-means clusters/groups: here we see that there is only 1 representative from group 4, so probably won't be able to use that group for any calculations.
But the others are workable.

For the different taxonomic levels, suborder seems workable, it has \>= 5 validation units in any given level.
I think order is too broad, and by the time we get to sub-group, we have two subgroups with just 1 validation unit each, so would have to drop those.

### Original tables

-   For soil cluster, suborder, and MLRA the minimum number of validation points we have in any given group is 5

```{r}

val_all_clim %>% 
  count(k_8)

val_all_clim %>% 
  count(mlra_short)

val_all_clim %>% 
  count(taxorder)

val_all_clim %>% 
  count(taxsuborder) 

val_all_clim %>% 
  count(taxgrtgroup)

val_all_clim %>% 
  count(taxsubgrp)

val_all_clim %>% count(taxclname)

xtabs(~region+taxorder, data = val_all_clim)


```

```{r}
#| echo: false

suborder_gt <- val_all_clim %>% 
  count(taxsuborder) %>% 
    gt() %>% 
    cols_label(taxsuborder = "Suborder") %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

mlra_gt <- val_all_clim %>% 
  count(MLRA_NAME) %>% 
    gt() %>% 
    cols_label(MLRA_NAME = "MLRA") %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

km_gt <- val_all_clim %>% 
  count(k_8) %>% 
    gt() %>% 
    cols_label(k_8 = "K-means Cluster") %>% 
  # tab_footnote(footnote = "Cluster 4 not included in tests",
  #              placement = "right") %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

grt_gt <- val_all_clim %>% 
  count(taxgrtgroup) %>% 
  gt() %>% 
  cols_label(taxgrtgroup = "Great Group") %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

    

gtsave(suborder_gt, "figs/suborder_counts.png")  

gtsave(mlra_gt, "figs/mlra_counts.png")

gtsave(km_gt, "figs/km_group_counts.png")

gtsave(grt_gt, "figs/great_group_counts.png")
```

### New combinations in response to reviewer comments

-   soil cluster (8) + climate zone (3) = 9 classes to compare in our validation data

    -   Minimum number validation pts in group = 1 (soil cluster 4) which was true above too and we dropped it.
        After that the minimum number is n=5 validation points

    -   9 categories total, 8 if we drop the one with n=1 validation point

-   MLRA + suborder = 10 classes to compare in our validation data (drop n=1, n=2 classes)

    -   Central MN Sandy Outwash x Aquolls n=1

    -   Rolling Till Prairie Aquolls n = 2

    -   Central MN Sandy Outwash Udolls = 4

    -   12 categories total, 10 if we drop the categories listed above with n=1 and n=2 members

-   suborder + family texture = 7 classes to compare in our validation data

    -   Aquerts x very fine n=3

    -   "The descriptive terms in the names of families are given in a consistent order, which is as follows: particle-size class, mineralogy class, cation-exchange activity class, calcareous and reaction class, soil temperature class, soil depth class, rupture resistance class, classes of coatings, and classes of cracks." Pg 157 Soil Taxonomy 2nd ed.
        1999

    -   7 categories total

-   suborder + climate zone(3) = 8 classes to compare in our validation data

    -   Aqualfs x climate cluster 3 n=5

    -   8 categories total

-   great group + climate zone(3) = 10 classes to compare in our validation data

    -   Argiaquolls x climate cluster 2 n=3, then two groups with n=5 validation points

    -   10 categories total

```{r}
# soil cluster & climate cluster
val_all_clim %>% 
  group_by(k_8, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  select(clim_k_3, k_8, n_val_pts, val_pt_ids) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Soil cluster within climate zone") %>% 
  cols_label(k_8 = "Soil cluster",
             clim_k_3 = "Climate zone",
             n_val_pts = "Validation pts (n)",
             val_pt_ids = "Validation pt IDs")

clust_clim_gt <- val_all_clim %>% 
  group_by(k_8, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  select(clim_k_3, k_8, n_val_pts) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Soil cluster within climate zone") %>% 
  cols_label(k_8 = "Soil cluster",
             clim_k_3 = "Climate zone",
             n_val_pts = "Validation pts (n)") %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

clust_clim_gt

gtsave(clust_clim_gt, "figs/clust_climzone_counts.png")
```

```{r}
# MLRA and suborder
val_all_clim %>% 
  group_by(MLRA_NAME, taxsuborder) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "MLRA + suborder") %>% 
  cols_label(
    MLRA_NAME = "MLRA name",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

mlra_suborder_gt <- val_all_clim %>% 
  group_by(MLRA_NAME, taxsuborder) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "MLRA + suborder") %>% 
  cols_label(
    MLRA_NAME = "MLRA name",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

mlra_suborder_gt

gtsave(mlra_suborder_gt, "figs/mlra_suborder_counts.png")
```

```{r}
# suborder + family texture
val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxsuborder, particle_size_class) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Suborder + particle size class") %>% 
  cols_label(
    particle_size_class = "Particle size class",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

suborder_texture_gt <- val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxsuborder, particle_size_class) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Suborder + particle size class") %>% 
  cols_label(
    particle_size_class = "Particle size class",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

suborder_texture_gt

gtsave(suborder_texture_gt, "figs/suborder_texture_counts.png")


```

```{r}
# suborder + climate
val_all_clim %>% 
  group_by(taxsuborder, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  select(clim_k_3, taxsuborder, n_val_pts, val_pt_ids) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Suborder within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate zone",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

suborder_climate_gt <- val_all_clim %>% 
  group_by(taxsuborder, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  select(clim_k_3, taxsuborder, n_val_pts) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Suborder within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate zone",
    taxsuborder = "Suborder",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

suborder_climate_gt

gtsave(suborder_climate_gt, "figs/suborder_climate_counts.png")

```

```{r}

# great group and climate
val_all_clim %>% 
  group_by(taxgrtgroup, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  select(clim_k_3, taxgrtgroup, n_val_pts, val_pt_ids) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Great Group within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate Zone",
    taxgrtgroup = "Great Group",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

grtgrp_clim_gt <- val_all_clim %>% 
  group_by(taxgrtgroup, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  select(clim_k_3, taxgrtgroup, n_val_pts) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Great Group within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate zone",
    taxgrtgroup = "Great Group",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

grtgrp_clim_gt

gtsave(grtgrp_clim_gt, "figs/grtgrp_clim_counts.png")



```

```{r}

# MLRA and soil cluster
val_all_clim %>% 
  group_by(MLRA_NAME, k_8) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Soil cluster within MLRA") %>% 
  cols_label(
    MLRA_NAME = "MLRA name",
    k_8 = "Soil cluster",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

mlra_cluster_gt <- val_all_clim %>% 
  group_by(MLRA_NAME, k_8) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Soil cluster within MLRA") %>% 
  cols_label(
    MLRA_NAME = "MLRA name",
    k_8 = "Soil cluster",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

mlra_cluster_gt

gtsave(mlra_cluster_gt, "figs/mlra_cluster_counts.png")


```

```{r}

# order + climate 

val_all_clim %>% 
  group_by(taxorder, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  select(clim_k_3, taxorder, n_val_pts, val_pt_ids) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Order within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate zone",
    taxorder = "Order",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

order_climate_gt <- val_all_clim %>% 
  group_by(taxorder, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  select(clim_k_3, taxorder, n_val_pts) %>% 
  arrange(clim_k_3) %>% 
  gt() %>% 
  tab_header(title = "Order within climate zone") %>% 
  cols_label(
    clim_k_3 = "Climate zone",
    taxorder = "Order",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)



order_climate_gt
```

```{r}

# order + particle size

val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxorder, particle_size_class) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Order + particle size class") %>% 
  cols_label(
    particle_size_class = "Particle size class",
    taxorder = "Order",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

order_texture_gt <- val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxorder, particle_size_class) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Order + particle size class") %>% 
  cols_label(
    particle_size_class = "Particle size class",
    taxorder = "Order",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

order_texture_gt

```

```{r}

# order + particle size? + climate? 

val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxorder, particle_size_class, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            val_pt_ids = str_c(val_unit_id, collapse = ", "),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Order + particle size class + climate") %>% 
  cols_label(
    particle_size_class = "Particle size class",
    taxorder = "Order",
    clim_k_3 = "Climate zone",
    n_val_pts = "Validation pts (n)",
    val_pt_ids = "Validation pt IDs"
  )

order_texture_clim_gt <- val_all_clim %>%
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>%
  group_by(taxorder, particle_size_class, clim_k_3) %>% 
  summarise(n_val_pts = n(),
            .groups = "drop") %>% 
  gt() %>% 
  tab_header(title = "Order + particle size class + climate") %>% 
  cols_label(
    clim_k_3 = "Climate Zone",
    particle_size_class = "Particle size class",
    taxorder = "Order",
    n_val_pts = "Validation pts (n)"
  ) %>% 
  opt_stylize(color = "blue", add_row_striping = TRUE, style = 2)

order_texture_clim_gt

```

## Create additional group variables

Above we explored how many validation points would be present in each class when we start grouping by multiple variables (suborder + MLRA or suborder + particle size class).
I need to add these new grouping variables as columns in my dataset before I can run one-way ANOVAs below.

On 3/29/24 Nic and I talked again about which additional grouping variables we should included in the edited version of the manuscript.
Decided we would do all the reasonable 2- and 3-way combinations of grouping variables listed below.
By "reasonable" we mean that we aren't going to do things that are circular / redundant like MLRA + Climate or MLRA + particle size.
Here is the list of single variables:

-   Order

-   Suborder

-   Climate zone

-   MLRA

-   Particle size class (from family)

-   KM cluster

```{r}

var_grps <- c("order", "suborder", "climate zone", "mlra", "partsize")


combos_2way <- expand_grid(first = var_grps, second = var_grps) %>%
  filter(
    # drop b/c circular
    !(first == second),!(first == "climate zone" & second == "mlra"),
    !(first == "mlra" & second == "climate zone"),
    !(first == "order" & second == "suborder"),
    !(first == "suborder" & second == "order"),
   # !(first == "mlra" & second == "partsize"),
    !(first == "partsize" & second == "mlra"),
# drop b/c duplicated
    !(first == "climate zone" & second == "order"),
    !(first == "mlra" & second == "order"),
    !(first == "partsize" & second == "order"),
    !(first == "climate zone" & second == "suborder"),
    !(first == "mlra" & second == "suborder"),
    !(first == "partsize" & second == "climate zone"),
!(first == "partsize" & second == "suborder")
  ) %>%
    mutate(two_way = glue("{first}_{second}"))
  
  combos_3way <-
    expand_grid(first = combos_2way$first, second = combos_2way$two_way) %>%
    filter(# drop 3-way combos where one variable is repeated
      !(str_detect(second, first)),
      !(first == "suborder" & str_detect(second, "order"))) %>%
    distinct() %>%
    filter(!(first == "climate zone" & str_detect(second, "mlra")),
           first != "climate zone") %>%
    mutate(combo_3way = glue("{first}_{second}"))
  
c(combos_2way$two_way, combos_3way$combo_3way) %>% 
  data.frame(to_test = .) %>% 
  add_row(to_test = "order") %>% 
  add_row(to_test = "particle size class")
  

```

"

```{r}

val_all_grps <- val_all_clim %>% 
  separate_wider_delim(
    cols = taxclname,
    names = c(
      "particle_size_class",
      "mineralogy_class",
      "cec_activity_class",
      "subgroup",
      "other"
    ),
    delim = ',',
    too_few = "align_start"
  ) %>% 
  mutate(
    clim_k_3 = str_replace(clim_k_3, "Cluster_", ""),
    km_soil_clim = glue("soil{k_8}_clim{clim_k_3}"),
    suborder_clim = glue("{taxsuborder}_clim{clim_k_3}"),
    suborder_partsize = glue("{taxsuborder}_{particle_size_class}"),
    suborder_mlra = glue("{taxsuborder}_{mlra_short}"),
    order_partsize = glue("{taxorder}_{particle_size_class}"),
    clim_order_partsize = glue("clim{clim_k_3}_{taxorder}_{particle_size_class}"),
    mlra_km = glue("{mlra_short}_soil{k_8}"),
    mlra_partsize = glue("{mlra_short}_{particle_size_class}"),
    partsize = particle_size_class,
    clim_order = glue("{clim_k_3}_{taxorder}"),
    mlra_order = glue("{mlra_short}_{taxorder}"),
    order_partsize = glue("{taxorder}_{particle_size_class}"),
    clim_partsize = glue("{clim_k_3}_{particle_size_class}"),
    clim_suborder_partsize = glue("{clim_k_3}_{taxsuborder}_{particle_size_class}")
  )

write_csv(val_all_grps, "data/validation_data_all_grouping_factors.csv")

```

```{r}

all_combos_to_test <- val_all_grps %>% 
  select(
         mlra_short,
         taxorder,
         taxsuborder,
         partsize,
         soil_group, 
         mlra_short,
         km_soil_clim:clim_suborder_partsize
         )

grouping_factors <- colnames(all_combos_to_test)


# https://stackoverflow.com/questions/63947104/how-do-i-unquote-a-character-column-name-for-fableaggregate-key
group_counts <-
  map(.x = grouping_factors, ~ count(x = all_combos_to_test,!!rlang::sym(.x)))

grp_counts_named <- set_names(group_counts, nm = grouping_factors)
  
write.xlsx(grp_counts_named, "data/counts_for_all_groupings.xlsx")
  

```

## Crosstabs w/ UD

Was originally thinking about whether we should include or exclude UD (undisturbed/unfarmed sites) because we know they are a major source of variance (they have much higher values across the board for all these indicators).

```{r}
xtabs(~soil_group + taxsuborder, data = val_all_grps)

xtabs(~taxgrtgroup + soil_group, data = val_all_grps)

xtabs(~mlra_short + soil_group, data = val_all_grps)

xtabs(~mlra_short + particle_size_class, data = val_all_grps)


# xtabs(~suborder_mlra + mlra_km, data = val_all_grps, drop.unused.levels = TRUE, sparse = TRUE) 
# 
# xtabs(~km_soil_clim + order_partsize_clim, data = val_all_grps, sparse = TRUE, drop.unused.levels = TRUE)


val_all_grps %>% 
  count(km_soil_clim, order_partsize) %>% 
  pivot_wider(names_from = "order_partsize",
              values_from = n) %>% 
  mutate(across(.cols = where(is.numeric), .fns = ~ifelse(is.na(.x), 0, .x)))


val_all_grps %>% 
  count(km_soil_clim, clim_order_partsize) %>% 
  mutate(across(.cols = c("km_soil_clim", "clim_order_partsize"), 
                .fns = ~str_remove(.x, pattern = "clim"))) %>% 
  pivot_wider(names_from = "km_soil_clim",
              values_from = n) %>% 
  mutate(across(.cols = where(is.numeric), .fns = ~ifelse(is.na(.x), 0, .x))) %>% 
  gt() %>% 
  data_color(
    columns = contains("soil"),
    method = "numeric",
    palette = "viridis",
    domain = c(1, 15),
    na_color = "white"
  )




```

```{r}

val_all_grps %>% 
  count(mlra_km, suborder_mlra) %>% 
  pivot_wider(names_from = "suborder_mlra",
              values_from = n) %>% 
  mutate(across(.cols = where(is.numeric), .fns = ~ifelse(is.na(.x), 0, .x))) %>% 
  gt() %>% 
  data_color(
    columns = -c("mlra_km"),
    method = "numeric",
    palette = "viridis",
    domain = c(1, 15),
    na_color = "white"
  )
```

## Crosstabs w/out UD

```{r}
val_farm <- val_all_grps %>% 
  filter(!str_detect(val_unit_id, "UD"))

xtabs(~soil_group + region, data = val_farm)

xtabs(~soil_group + taxsuborder, data = val_farm)

xtabs(~taxgrtgroup + soil_group, data = val_farm)



```

### Checking distributions

Transformations needed (based on inspecting the plots below):

-   None: aggregate stability, POXC, SOC
-   Log10: total biomass PLFA, total bacteria PLFA, total fungi PLFA, MBC, MBN, PMC

```{r}
#| echo: false

plot_transformations <- function(var,
                                 df,
                                 log10_adjust = 0,
                                 ln_adjust = 0,
                                 sqrt_adjust = 0,
                                 nbins = 30) {
  trans_df <- df %>%
    select(val_unit_id, {{var}}) %>%
    mutate(
      log10_trans = log10({{var}} + log10_adjust),
      ln_trans = log({{var}} + ln_adjust),
      sqrt_trans = sqrt({{var}} + sqrt_adjust)) %>%
  pivot_longer(cols = -c(val_unit_id))
  
  var_string <- deparse(substitute(var))


  trans_df %>%
    ggplot(aes(x = value)) +
    geom_histogram(bins = nbins) +
    facet_wrap(vars(name), scales = "free") +
    theme_bw() +
    ggtitle(glue("{var_string}"))

}
```

#### SOC

```{r}
plot_transformations(var = org_c_wt_percent,
                     df = val_all_clim,
                     nbins = 15)


```

#### Aggregate stability

```{r}

plot_transformations(var = corr_percent_stable_gr2mm,
                     df = val_all,
                     nbins = 15)

```

#### PLFA Indicators

```{r}

plot_transformations(var = total_living_microbial_biomass_plfa_ng_g,
                     df = val_all,
                     nbins = 15)

plot_transformations(var = total_bacteria_plfa_ng_g,
                     df = val_all,
                     nbins = 15)

plot_transformations(var = total_fungi_plfa_ng_g,
                     df = val_all,
                     nbins = 15)

```

#### Microbial biomass C & N (CFE)

```{r}

plot_transformations(var = mbc_ug_g_soil,
                     df = val_all,
                     nbins = 15)

plot_transformations(var = mbn_ug_g_soil,
                     df = val_all,
                     nbins = 15)

```

#### POXC

```{r}
plot_transformations(var = poxc_mg_kg,
                     df = val_all,
                     nbins = 15)
```

#### PMC

```{r}
plot_transformations(var = ugC_g_day,
                     df = val_all,
                     nbins = 10)
```

## Function to plot model checks

```{r}

check_plots_anova <- function(soil_var, strat, df, log_trans) {
  
  dat_no_na <- df %>%
    select(val_unit_id,
           all_of(strat),
           all_of(soil_var)) %>%
    drop_na(all_of(soil_var))
  
  # checking if any groups are represented by 2 or less data points. Want to d
  # drop these so we can actually calculate variance for the group

  n_obs_per_group <- dat_no_na %>%
    count(.data[[strat]])
  
  single_obs_groups <- n_obs_per_group %>%
    filter(n <= 2) %>%
    pull(.data[[strat]])
  
  if (length(single_obs_groups) == 0) {
    dat_subset <- dat_no_na
    
  } else{
    dat_subset <- dat_no_na %>%
      filter(!(.data[[strat]] %in% single_obs_groups))
    
  }
  
  if (log_trans){
    
    f <- paste0("log(", soil_var, ") ~ ", strat)
    
  }else{
    
    f <- paste0(soil_var, " ~ ", strat)
    
  }
  
  mod <- lm(formula = f,
            data = dat_subset)
  
  norm <- plot(check_normality(mod))
  homog <- plot(check_homogeneity(mod))


  return(list(f_used = f,
              plots = list(norm, homog)))
  
}
```

## Models to check

Working with these independent variables (stratification options):

1.  soil_group (k-means);
2.  mlra_short
3.  taxsuborder
4.  taxgrtgroup
5.  Soil + climate clusters
6.  Suborder + climate
7.  Suborder + particle size class
8.  Suborder + MLRA
9.  Order + particle size + climate zone
10. Soil cluster within MLRA

```{r}

(dep_vars <- c("corr_percent_stable_gr2mm",
               "ugC_g_day",
               "poxc_mg_kg",
               "mbc_ug_g_soil",
               "mbn_ug_g_soil", # include MBN?
               "total_living_microbial_biomass_plfa_ng_g",
               "total_bacteria_plfa_ng_g",
               "total_fungi_plfa_ng_g",
               "org_c_wt_percent" 
))

# determined by inspecting histograms above w/ different
# transformation options
log_trans <- c(FALSE, 
               TRUE, 
               FALSE, 
               TRUE,
               TRUE,
               TRUE,
               TRUE,
               TRUE,
               FALSE)

```

### K-means soil groups

```{r}
#| warning: false

map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "soil_group",
    df = val_all_grps
  )
)


```

### Region

```{r}
#| warning: false

map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "region",
    df = val_all_grps
  )
)
```

### Suborder

```{r}
#| warning: false

map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "taxsuborder",
    df = val_all_grps
  )
)
```

### Great group

```{r}
#| warning: false


map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "taxgrtgroup",
    df = val_all_grps
  )
)


```

### Soil + climate clusters

```{r}
#| warning: false


map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "km_soil_clim",
    df = val_all_grps
  )
)


```

### Suborder + climate

```{r}
#| warning: false


map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "suborder_clim",
    df = val_all_grps
  )
)



```

### Suborder + particle size class

```{r}
#| warning: false


map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "suborder_partsize",
    df = val_all_grps
  )
)


```

### Suborder + MLRA

```{r}
#| warning: false


map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "suborder_mlra",
    df = val_all_grps
  )
)


```

### Order + particle size class + climate

```{r}

map2(
  .x = dep_vars,
  .y = log_trans,
  .f = ~ check_plots_anova(
    soil_var = .x,
    log_trans = .y,
    strat = "clim_order_partsize",
    df = val_all_grps
  )
)

```

## Effect sizes for variance explained

**Add updated references** from reading notes on 2023-03-16 re: calculating effect sizes from F statistics (which is what `{effectsize}` is doing for us behind the scenes when we pass the Welch's ANOVA results to `epsilon_squared()`

I was originally planning on calculating eta-squared as my effect size, using either: [`effectsize::eta_squared()`](https://easystats.github.io/effectsize/reference/eta_squared.html) for ANOVA or [`effectsize::rank_eta_squared()`](https://easystats.github.io/effectsize/reference/rank_epsilon_squared.html)`.` But in reading the [documentation](https://easystats.github.io/effectsize/reference/eta_squared.html) for `eta_squared()` from `{effectsize}`, I learned that there are other, less biased options for calculating this value: omega-squared and epsilon-squared.

I found a very helpful, recent reference, Iacobucci et al., (2023), that explains the differences between eta, epsilon, and omega when used as effect sizes of variance explained.
See their paper for the details, but the easiest way to think about it is that using epsilon-squared or omega-squared is essentially like reporting an adjusted R2 value instead of a regular R2 value.
It's better to use epsilon squared because the equation accounts for small sample size, which is relevant in our case.

Below is an example with MBC, this is just me figuring out what the different functions outputs look like, and how NAs are handled.

### Example

```{r}

## welch's ANOVA - MBC by soil_group (k-means)
# need to drop grp-4 because only 1 observation, can't
# calculate variance. Wrote this step into the function
# calc_welch_eps_sq() below.
sub_dat <- val_all_grps %>% 
  filter(soil_group != "grp-4")


test_welch <- oneway.test(data = sub_dat,
            formula = mbc_ug_g_soil ~ soil_group,
           var.equal = FALSE,
            na.action = "na.omit")

test_welch

effectsize::epsilon_squared(test_welch, partial = FALSE)

```

Below I test out Welch's ANOVA followed by calculation of epsilon squared.
This works, and after reading more from the `{effectsize}` documentation [here](https://easystats.github.io/effectsize/reference/F_to_eta2.html) I think I understand how.
I can pass the result from `oneway.test(var.equal = FALSE)` to `effectsize::epsilon_squared()` and there is an intermediate step performed where the F statistic from `oneway.test` is converted to the effect size (could be partial eta-squared, omega-squared, or epsilon-squared)

### Setup dataframe

Transformations needed:

-   None: aggregate stability, POXC, SOC
-   Log10: total biomass PLFA, total bacteria PLFA, total fungi PLFA, MBC, MBN, PMC

```{r}
# grouping_factors is constructed above in section "Create additional
# grouping variables" 
strat_opts <- grouping_factors

mod_frame <- tidyr::crossing(dep_vars, strat_opts)

# apply the transformations I decided on above after looking at 
# "checking distributions" plots
dat_trans <- val_all_grps %>% 
  mutate(across(.cols = c(total_living_microbial_biomass_plfa_ng_g,
                          total_bacteria_plfa_ng_g,
                          total_fungi_plfa_ng_g,
                          mbc_ug_g_soil,
                          mbn_ug_g_soil,
                          ugC_g_day), 
                .fns = log10
                ))
# creating a farm dataset so I can compare results 
# for including vs. excluding UD sites
dat_farm <- dat_trans %>% 
  filter(!str_detect(val_unit_id, "UD"))
```

### Function run ANOVA & calculate epsilon squared

```{r}


calc_welch_eps_sq <- function(soil_var,
                              strat,
                              df = dat_trans) {
  # count observations (validation points) per group
  # based on stratification variable provided
  n_obs_per_group <- df %>%
    count(.data[[strat]])
  
  # identify groups with 2 or less validation points
  # want to drop these (because we need to be able to 
  # calculate variance
  few_obs_groups <- n_obs_per_group %>%
    filter(n <= 2) %>%
    pull(.data[[strat]])
  
  if (length(few_obs_groups) == 0){
    dat_subset <- df
    
  }else{
    dat_subset <- df %>%
      filter(!(.data[[strat]] %in% few_obs_groups))
  }
    
    my_formula <- as.formula(paste0(soil_var, " ~ ", strat))
    
    
    mod_obj <- oneway.test(
      formula = my_formula,
      data = dat_subset,
      var.equal = FALSE,
      na.action = "na.omit"
    )
    
    eps_sq <- effectsize::epsilon_squared(model = mod_obj,
                                          # partial FALSE b/c one-way test
                                          # we don't have other vars to
                                          # break the variance down by
                                          partial = FALSE)
    
    return(eps_sq)
    
}


  

```

### Calculate epsilon squared

```{r}
#| message: false
#| warning: false

# quieted the message "`var.equal = FALSE` - effect size is an approximation.", it's a reminder that this effect size is an apporximation because we are estimating it based on the f statistic from our Welch's ANOVA

eps_inputs <- mod_frame %>% 
  rename(strat = strat_opts, 
         soil_var = dep_vars) %>% 
  select(soil_var, strat) 

# returns bunch of reminders about how the eff size is 
# an approximation (b/c we are calculating it from F stat,
# not directly from SS)
eps_results <- eps_inputs %>%
  mutate(eps_results = map2(
    .x = soil_var,
    .y = strat,
    .f = ~ calc_welch_eps_sq(
      soil_var = .x,
      strat = .y,
      df = dat_trans
    )
  ))


eps_farm <- eps_inputs %>%
  mutate(eps_results = map2(
    .x = soil_var,
    .y = strat,
    .f = ~ calc_welch_eps_sq(
      soil_var = .x,
      strat = .y,
      df = dat_farm
    )
  ))


```

### Clean up data

```{r}


eps_long <- eps_results %>% 
  unnest(eps_results) %>% 
  rename(epsilon_sq = Epsilon2)


farm_long <- eps_farm %>% 
  unnest(eps_results) %>% 
  rename(epsilon_sq = Epsilon2)

# eps_wide <- eps_long %>% 
#   pivot_wider(values_from = c("epsilon_sq", "type"), 
#               names_from = "strat")
```

### Table of variance explained (W/ UD)

```{r}

var_tbl_ud <- eps_long %>% 
  mutate(soil_var = case_when(
    str_detect(soil_var, "stable") ~ "Agg Stab",
    str_detect(soil_var, "mbc") ~ "MBC",
    str_detect(soil_var, "mbn") ~ "MBN",
    str_detect(soil_var, "poxc") ~ "POXC",
    str_detect(soil_var, "total_bact") ~ "Bact PLFA",
    str_detect(soil_var, "total_fungi") ~ "Fungi PLFA",
    str_detect(soil_var, "total_living") ~ "Total PLFA",
    str_detect(soil_var, "ugC") ~ "PMC",
    str_detect(soil_var, "org_c") ~ "SOC"
  )) %>% 
  select(soil_var, strat, epsilon_sq) %>% 
  pivot_wider(names_from = "soil_var",
              values_from = "epsilon_sq") %>% 
  mutate(across(where(is.numeric), ~round(.x, digits = 2))) %>% 
  gt() %>% 
  tab_header(title = "Epsilon squared (variation explained) with UD") 

  
var_tbl_ud

gtsave(var_tbl_ud, filename = "variation_explained_with_ud.docx")



```

### Table of variance explained (no UD)

```{r}

var_tbl_farm <- farm_long %>% 
  mutate(soil_var = case_when(
    str_detect(soil_var, "stable") ~ "Agg Stab",
    str_detect(soil_var, "mbc") ~ "MBC",
    str_detect(soil_var, "mbn") ~ "MBN",
    str_detect(soil_var, "poxc") ~ "POXC",
    str_detect(soil_var, "total_bact") ~ "Bact PLFA",
    str_detect(soil_var, "total_fungi") ~ "Fungi PLFA",
    str_detect(soil_var, "total_living") ~ "Total PLFA",
    str_detect(soil_var, "ugC") ~ "PMC",
    str_detect(soil_var, "org_c") ~ "SOC"
  )) %>% 
  select(soil_var, strat, epsilon_sq) %>% 
  pivot_wider(names_from = "soil_var",
              values_from = "epsilon_sq") %>% 
  mutate(across(where(is.numeric), ~round(.x, digits = 2))) %>% 
  gt() %>% 
 tab_header(title = "Epsilon squared (variation explained) no UD") 
  
var_tbl_farm
gtsave(var_tbl_farm, "variation_explained_farms_only.docx")

```

```{r}


strat_opts <- c("soil_group", "mlra_short", "taxsuborder",
                "taxgrtgroup", "km_soil_clim", "suborder_clim",
                "suborder_partsize", "suborder_mlra", "order_partsize_clim",
                "mlra_km")


dat_farm %>% 
  count(soil_group)

dat_farm %>% 
  count(km_soil_clim)

dat_farm %>% 
  count(mlra_short)

dat_farm %>% 
  count(suborder_mlra)

dat_farm %>% 
  count(mlra_km)

dat_farm %>% 
  count(taxsuborder)

dat_farm %>% 
  count(suborder_partsize)

dat_farm %>% 
  count(order_partsize_clim)

dat_farm %>% 
  count(taxgrtgroup)

```

### Plots of variance explained

```{r}
all_pts_labelled <- eps_long %>% 
 # filter(strat != "taxgrtgroup") %>% 
  mutate(soil_var = case_when(
    soil_var == "mbc_ug_g_soil" ~ "MBC",
    soil_var == "mbn_ug_g_soil" ~ "MBN", 
    soil_var == "corr_percent_stable_gr2mm" ~ "Aggregate Stab.",
    soil_var == "poxc_mg_kg" ~ "POXC", 
    soil_var == "total_bacteria_plfa_ng_g" ~ "Bacteria PLFA",
    soil_var == "total_fungi_plfa_ng_g" ~ "Fungi PLFA",
    soil_var == "total_living_microbial_biomass_plfa_ng_g" ~ "Total Biomass PLFA", 
    soil_var == "poxc_mg_kg" ~ "POXC",
    soil_var == "ugC_g_day" ~ "PMC",
    soil_var == "org_c_wt_percent" ~ "SOC"
  ),
  strat = case_when(
    strat == "mlra_short" ~ "MLRA",
    strat == "soil_group" ~ "KM CLUSTER SOIL",
    strat == "taxsuborder" ~ "SUBORDER",
    strat == "km_soil_clim" ~ "KM CLUSTER SOIL x\nCLIMATE",
    strat == "suborder_clim" ~ "SUBORDER x\nCLIMATE",
    strat == "suborder_mlra" ~ "MLRA x\nSUBORDER",
    strat == "suborder_partsize" ~ "SUBORDER x\nPARTICLE SIZE CLASS",
    strat == "taxgrtgroup" ~ "GREAT GROUP"
  )) %>%
  group_by(soil_var) %>%
  mutate(max_epsilon = max(epsilon_sq),
         top_strat = case_when(
           epsilon_sq == max_epsilon ~ "Y",
           TRUE ~ "N"
         ), 
  # round for nice labels 
         epsilon_sq_lab = round(epsilon_sq, digits = 2))

```

```{r}

# saving in case I want to compare farm (no UD) vs. w/ UD results

farm_labelled <- farm_long %>%
  filter(strat != "taxgrtgroup") %>%
  mutate(soil_var = case_when(
    soil_var == "mbc_ug_g_soil" ~ "MBC",
    soil_var == "mbn_ug_g_soil" ~ "MBN",
    soil_var == "corr_percent_stable_gr2mm" ~ "Aggregate Stab.",
    soil_var == "poxc_mg_kg" ~ "POXC",
    soil_var == "total_bacteria_plfa_ng_g" ~ "Bacteria PLFA",
    soil_var == "total_fungi_plfa_ng_g" ~ "Fungi PLFA",
    soil_var == "total_living_microbial_biomass_plfa_ng_g" ~ "Total Biomass PLFA",
    soil_var == "poxc_mg_kg" ~ "POXC",
    soil_var == "ugC_g_day" ~ "PMC"
  ),
  strat = case_when(
    strat == "mlra_short" ~ "MLRA",
    strat == "soil_group" ~ "KM CLUSTER SOIL",
    strat == "taxsuborder" ~ "SUBORDER",
    strat == "km_soil_clim" ~ "KM CLUSTER SOIL x\nCLIMATE",
    strat == "suborder_clim" ~ "SUBORDER x\nCLIMATE",
    strat == "suborder_mlra" ~ "MLRA x\nSUBORDER",
    strat == "suborder_partsize" ~ "SUBORDER x\nPARTICLE SIZE CLASS",
    strat == "taxgrtgroup" ~ "GREAT GROUP"
  )) %>%
  group_by(soil_var) %>%
  mutate(max_epsilon = max(epsilon_sq),
         top_strat = case_when(
           epsilon_sq == max_epsilon ~ "Y",
           TRUE ~ "N"
         ), 
  # round for nice labels 
         epsilon_sq_lab = round(epsilon_sq, digits = 2))

```

## (with UD) variance explained plot

Like original, just soil cluster (KM Cluster), MLRA, and suborder

```{r}

plot_var_order <-
  c(
    "POXC",
    "SOC",
  #  "Total Biomass PLFA",
    "Bacteria PLFA",
    "MBC",
    "MBN",
    "Fungi PLFA",
    "Aggregate Stab.",
    "PMC"
  )


eps_bar_plot <- all_pts_labelled %>%
  filter(soil_var != "Total Biomass PLFA",
         strat %in% c("KM CLUSTER SOIL",
                      "MLRA",
                      "SUBORDER"
                    #  "GREAT GROUP"
                      )) %>% 
  ggplot() +
  geom_col(aes(x = soil_var, y = epsilon_sq_lab, fill = strat),
           position = position_dodge(),
           width = 0.7, 
           color = "black") +
  # geom_text(aes(x = 8.25, y = 0.85, label = "A."), size = 3) +
  #   geom_text(aes(x = 6.25, y = 0.85, label = "B."), size = 3) +
  #   geom_text(aes(x = 4.25, y = 0.85, label = "C."), size = 3) +
  #   geom_text(aes(x = 1.25, y = 0.85, label = "D."), size = 3) +
  scale_x_discrete(limits = rev(plot_var_order)) +
  scale_y_continuous(breaks = seq(0, 0.9, 0.1), limits = c(0, 0.9)) +
#   geom_vline(aes(xintercept = 1.5)) +
#   geom_vline(aes(xintercept = 4.5)) +
#   geom_vline(aes(xintercept = 6.5)) +
  coord_cartesian(xlim = c(0, 0.7),
                  clip = 'off') +
  coord_flip() +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(hjust = 1),
    legend.text = element_text(size = 8),
    legend.justification = c(1, 1)
  ) +
  xlab("") +
  ylab("Epsilon Squared") +
  #labs(caption = "With undisturbed (Welch's ANOVA)") +
  scale_fill_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666')) +
  guides(fill = guide_legend(title = "Groups")) 

ggsave("figs/epsilon_sq_barplot_ud_update20240323.png", plot = eps_bar_plot, 
       width = 5, height = 5, units = "in")
```

Add climate / other grouping combinations (suborder + MLRA, suborder + particle size class, etc.)

```{r}

plot_var_order <-
  c(
    "POXC",
    "SOC",
  #  "Total Biomass PLFA",
    "Bacteria PLFA",
    "MBC",
    "MBN",
    "Fungi PLFA",
    "Aggregate Stab.",
    "PMC"
  )


eps_bar_plot_new <- all_pts_labelled %>%
  filter(soil_var != "Total Biomass PLFA",
         strat %in% c("KM CLUSTER SOIL x\nCLIMATE",
                      #"SUBORDER x\nCLIMATE",
                      "SUBORDER x\nPARTICLE SIZE CLASS",
                      "MLRA x\nSUBORDER")) %>% 
  ggplot() +
  geom_col(aes(x = soil_var, y = epsilon_sq_lab, fill = strat),
           position = position_dodge(),
           width = 0.7, 
           color = "black") +
  # geom_text(aes(x = 8.25, y = 0.85, label = "A."), size = 3) +
  #   geom_text(aes(x = 6.25, y = 0.85, label = "B."), size = 3) +
  #   geom_text(aes(x = 4.25, y = 0.85, label = "C."), size = 3) +
  #   geom_text(aes(x = 1.25, y = 0.85, label = "D."), size = 3) +
  scale_x_discrete(limits = rev(plot_var_order)) +
  scale_y_continuous(breaks = seq(0, 0.9, 0.1), limits = c(0, 0.9)) +
#   geom_vline(aes(xintercept = 1.5)) +
#   geom_vline(aes(xintercept = 4.5)) +
#   geom_vline(aes(xintercept = 6.5)) +
  coord_cartesian(xlim = c(0, 0.7),
                  clip = 'off') +
  coord_flip() +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(hjust = 1),
    legend.text = element_text(size = 8),
    legend.justification = c(1, 1)
  ) +
  xlab("") +
  ylab("Epsilon Squared") +
  #labs(caption = "With undisturbed (Welch's ANOVA)") +
  scale_fill_manual(values = c('#fb9a99','#33a02c','#b2df8a','#666666')) +
  guides(fill = guide_legend(title = "Groups")) 

ggsave("figs/epsilon_sq_barplot_ud_update20240323_newgrps.png", plot = eps_bar_plot_new, 
       width = 6, height = 5, units = "in")

```

## (No UD) variance explained table & plot

```{r}

farm_long %>% 
  filter(strat != "taxgrtgroup") %>% 
  mutate(soil_var = case_when(
    str_detect(soil_var, "stable") ~ "Agg Stab",
    str_detect(soil_var, "mbc") ~ "MBC",
    str_detect(soil_var, "mbn") ~ "MBN",
    str_detect(soil_var, "poxc") ~ "POXC",
    str_detect(soil_var, "total_bact") ~ "Bact PLFA",
    str_detect(soil_var, "total_fungi") ~ "Fungi PLFA",
    str_detect(soil_var, "total_living") ~ "Total PLFA",
    str_detect(soil_var, "ugC") ~ "PMC",
  )) %>% 
  select(soil_var, strat, epsilon_sq) %>% 
  pivot_wider(names_from = "strat",
              values_from = "epsilon_sq") %>% 
  mutate(across(where(is.numeric), ~round(.x, digits = 2)))

```

```{r}

# decided to use the same order as the above plot that also includes the UD data, to make comparison between them easier

# f_plot_var_order <- c("POXC", "Total Biomass PLFA","Aggregate Stab.", "Bacteria PLFA", "MBC", "MBN", "Fungi PLFA", "PMC")


farm_bar_plot <- farm_labelled %>%
  filter(soil_var != "Total Biomass PLFA") %>% 
  ggplot() +
  geom_col(aes(x = soil_var, y = epsilon_sq_lab, fill = strat),
           position = position_dodge(),
           width = 0.7,
           color = "black") +
  # geom_text(aes(x = 1, y = 0.9, label = "D."), size = 3) +
  # geom_text(aes(x = 3, y = 0.9, label = "C."), size = 3) +
  # geom_text(aes(x = 7.5, y = 0.9, label = "A."), size = 3) +
  #   geom_text(aes(x = 5.5, y = 0.9, label = "B."), size = 3) +
  scale_x_discrete(limits = rev(plot_var_order)) + 
  scale_y_continuous(breaks = seq(0, 1, 0.1), limits = c(0, 1.05)) +
 # geom_vline(aes(xintercept = 1.5)) +
 #  geom_vline(aes(xintercept = 4.5)) +
 #  geom_vline(aes(xintercept = 6.5)) +
  coord_flip() +
  theme_bw() +
theme(
    legend.position = "bottom",
    plot.title = element_text(hjust = 1),
    legend.text = element_text(size = 8),
    legend.justification = c(1, 1)
  ) +
  xlab("") +
  ylab("Epsilon Squared") +
  # labs(caption = "Just farm data/no undisturbed (Welch's ANOVA)") +
  scale_fill_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666')) +
  guides(fill = guide_legend(title = "Grouping Method"))

ggsave(
  "figs/epsilon_sq_barplot_farms_update20240317.png",
  plot = farm_bar_plot,
  width = 5,
  height = 5,
  units = "in"
)
```

## What is going on with PMC?

PMC returns 0% variance explained for all three stratification options: K-means, Region, and Taxonomic sub-group.
Is this really correct?
Let's double check below with the region stratification to make sure there isn't something weird with the data.

```{r}

lm_pmc <- lm(ugC_g_day ~ region, data = sub_dat, na.action = "na.omit")

aov_pmc <- car::Anova(lm_pmc, type = 2)

# big residuals number... that explains it
aov_pmc

effectsize::epsilon_squared(aov_pmc, partial = FALSE)

# what about eta-squared?
effectsize::eta_squared(aov_pmc, partial = FALSE)

# what if we drop the UD sites?

farmdat <- sub_dat %>% filter(!str_detect(val_unit_id, "UD"))

lm_farm <- lm(ugC_g_day ~ region, data = farmdat, na.action = "na.omit")

aov_farm <- car::Anova(lm_farm, type = 2)

# big residuals number... that explains it
aov_farm

effectsize::epsilon_squared(aov_farm, partial = FALSE)

# what about eta-squared?
effectsize::eta_squared(aov_farm, partial = FALSE)

```

## ANOVA models POXC

Trying this after reading Mourtzinis et al., 2020 about stratifying producer fields to better explain soybean yield variability

```{r}
#| eval: false 


# using poxc as example 
# check for missing values
nrow(sub_dat %>% filter(is.na(poxc_mg_kg)))

# summarise to mapunit level (val_unit_ids)
poxc_test <- sub_dat %>% 
  filter(!is.na(poxc_mg_kg)) %>% 
  group_by(val_unit_id, region, k_8) %>% 
  summarise(mean_poxc = mean(poxc_mg_kg),
            .groups = "drop") %>% 
  mutate(k_8 = glue("cl_{k_8}"))

reglm <- lm(mean_poxc ~ region, data = poxc_test)
#regposlm <- lm(mean_poxc ~ region*position, data = poxc_test)
clustlm <- lm(mean_poxc ~ k_8, data = poxc_test)

performance::check_model(reglm, check = c("normality", "linearity", "homogeneity", "outliers"))

anova_reg <- car::Anova(reglm) %>% broom::tidy() %>% column_to_rownames("term")

# anova_regpos <- car::Anova(regposlm) %>% broom::tidy() %>% column_to_rownames("term")
  
anova_clust <- car::Anova(clustlm) %>% broom::tidy() %>% 
  column_to_rownames("term")

# what percentage of variation is explained by the "region" term
# vs. the "cluster" term vs. the region and cluster terms (and their interaction?)

ss_reg <- anova_reg['region', 'sumsq']/sum(anova_reg['sumsq'])*100

# ss_regpos <- (anova_regpos['region', 'sumsq'] + 
#     anova_regpos['position', 'sumsq'] + 
#     anova_regpos['region:position', 'sumsq'] ) /sum(anova_reg['sumsq'])*100

ss_clust <- anova_clust['k_8', 'sumsq']/sum(anova_clust['sumsq'])*100


ss_reg
ss_regpos
ss_clust
```

## ANOVA models MBC

```{r}
#| eval: false


# using poxc as example 
# check for missing values
nrow(sub_dat %>% filter(is.na(mbc_ug_g_soil)))

mbc_test <- sub_dat %>% 
  filter(!is.na(mbc_ug_g_soil)) %>% 
  group_by(val_unit_id, region, k_8, position) %>% 
  summarise(mean_mbc = mean(mbc_ug_g_soil),
            .groups = "drop") %>% 
  mutate(k_8 = glue("cl_{k_8}"))

reglm <- lm(mean_mbc ~ region, data = mbc_test)
regposlm <- lm(mean_mbc ~ region*position, data = mbc_test)
clustlm <- lm(mean_mbc ~ k_8, data = mbc_test)

anova_reg <- car::Anova(reglm) %>% broom::tidy() %>% column_to_rownames("term")

anova_regpos <- car::Anova(regposlm) %>% broom::tidy() %>% column_to_rownames("term")
  
anova_clust <- car::Anova(clustlm) %>% broom::tidy() %>% 
  column_to_rownames("term")

# what percentage of variation is explained by the "region" term
# vs. the "cluster" term vs. the region and cluster terms (and their interaction?)

ss_reg <- anova_reg['region', 'sumsq']/sum(anova_reg['sumsq'])*100

ss_regpos <- (anova_regpos['region', 'sumsq'] + 
    anova_regpos['position', 'sumsq'] + 
    anova_regpos['region:position', 'sumsq'] ) /sum(anova_reg['sumsq'])*100

ss_clust <- anova_clust['k_8', 'sumsq']/sum(anova_clust['sumsq'])*100


ss_reg
ss_regpos
ss_clust
```

## (Old) Calculate coefficient of variation

Old stuff here but wanted to keep track of the cvequality package link in case it's useful at some other point...
My idea was to use coefficient of variation (%) to compare the spread of the points when grouped by geographic region vs. soil group.
I found a helpful R package to do this (which includes stats citations): [`{cvequality}`](https://cran.r-project.org/web/packages/cvequality/vignettes/how_to_test_CVs.html)
