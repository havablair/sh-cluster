{
  "hash": "672d0d0e076ae250aa707f11baad6a51",
  "result": {
    "markdown": "# Map unit aggregation {#sec-mu-agg}\n\nNow that I have soil properties calculated for my target COKEYs, I need to aggregate those values to the MUKEY level, weighting my average soil properties by the normalized component percentages.\nThis is necessary because we dropped all the components that were \\<15% of map unit area, and we want to calculate **component percent-weighted averages for** **MUKEYS** based on the proportions of the included components only.\n\nHere am trying to figure out a nice LaTeX equation for the generic weighted means formula:\n\n$$\n\\begin{equation}    W = \\dfrac{\\sum_{i=1}^{n}w_{i}X_{i}}{\\sum_{i=1}^{n}w_{i}}\\end{equation}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(glue)\n\n# soil prop data 0-20cm aggregated by component\n# drop the \"contributing fraction\" columns generated\n# during our slab operation b/c we don't need them here\ncmp <- read_csv(\"./data/wide_slab_aggregated_soil_props_20220912.csv\") %>% \n  select(-contains(\"contributing_fraction\"))\n\n# components with corresponding mukeys \ncmp_lookup <- read_csv(\"./data/component_list.csv\") %>% \n  select(cokey, mukey, comppct_r, compname, compkind, starts_with(\"tax\"))\n\n# this was created back in 04-subset-...\n# see my notes at end of this chap. about troubleshooting this\ndom_cmp_key <- read_csv(\"./data/key_dominant_component_percent.csv\")\n\n# used to explore which MUKEYs were excluded \n# based on data availability \nmukey_info <- read_csv(\"./data/target_mapunit_table.csv\")\n```\n:::\n\n\nRecall that we dropped 548 components because they didn't have data / did not refer to specific series (dumps, water, gravel pits, etc.), see @sec-missing.\nSo the `cmp` dataframe here has fewer rows than `cmp_lookup`.\n\n## Clustering Variables\n\nUsing the same variables they did in Devine et al., but added calcium carbonate (`caco3_r_value`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust_vars <- c(\n  \"claytotal_r_value\",\n  # \"silttotal_r_value\",\n  # \"sandtotal_r_value\",\n  \"om_r_value\",\n  \"cec7_r_value\",\n  \"dbthirdbar_r_value\",\n  #\"fragvol_r_sum_value\",\n  #\"kwfact_value\",  \n  \"ec_r_value\",\n  \"ph1to1h2o_r_value\",\n  \"caco3_r_value\",\n  \"lep_r_value\",\n  \"ksat_r_value\",\n  \"awc_r_value\"\n)  \n```\n:::\n\n\n## Drop incomplete cases\n\nI think we want to keep only complete cases for our COKEYs (all of the variables we want to cluster on should have a value).\nOtherwise that would mess with our clustering.\nHere I'm checking on how many `NA`s there are for the different variables, then I drop the incomplete cases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncmp %>% \n  select(cokey, all_of(clust_vars)) %>% \n  summarise(across(where(is.numeric), ~sum(is.na(.x)))) %>% \n  pivot_longer(cols = everything(), names_to = \"variable\",\n               values_to = \"n_missing\") %>% \n  arrange(desc(n_missing))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"variable\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"n_missing\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"ph1to1h2o_r_value\",\"2\":\"554\"},{\"1\":\"lep_r_value\",\"2\":\"377\"},{\"1\":\"claytotal_r_value\",\"2\":\"369\"},{\"1\":\"cec7_r_value\",\"2\":\"221\"},{\"1\":\"ec_r_value\",\"2\":\"9\"},{\"1\":\"om_r_value\",\"2\":\"4\"},{\"1\":\"dbthirdbar_r_value\",\"2\":\"4\"},{\"1\":\"caco3_r_value\",\"2\":\"4\"},{\"1\":\"awc_r_value\",\"2\":\"4\"},{\"1\":\"cokey\",\"2\":\"0\"},{\"1\":\"ksat_r_value\",\"2\":\"0\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nAnd keep only the complete cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# keep only cokey and clustering vars\ncmp_clust <- cmp %>% \n  select(cokey, all_of(clust_vars))\n\n# filter to include only complete cases \n# there are many ways to do this\n# another way would be filter(complete.cases(.))\ncmp_complete <- cmp_clust %>% drop_na()\n```\n:::\n\n\nSo we went from 10237 to 9387 COKEYs.\n(We dropped 850).\n\n## Create table for map unit data\n\nHere, I take the (complete only) component data (0-20cm weighted averages for all our soil properties) and join it to my lookup table, which includes MUKEY.\nThen I nest COKEY data (multiple COKEYs can belong to one MUKEY).\nThe result is a table with one row for each MUKEY.\n\nI also pull out some info about the number, min %, and max % of components in a given MUKEY for context.\n\nThe first time I did this, I forgot to deal with `NA`s in the `cmp` dataframe, and we had 7525 MUKEYs to work with.\nAfter filtering to include only complete cases based on the cluster variables defined above, we now have 7062 MUKEYs to work with.\nFor reference, Devine et al. had 4,595 for inclusion in their model (after an additional drop step based on sufficient data representation, see below @sec-dat-avail) .\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# nest by mukey\ncmp_nest <- left_join(cmp_complete, cmp_lookup, by = c(\"cokey\")) %>%\n  dplyr::select(cokey, mukey, everything()) %>%\n  dplyr::group_by(mukey) %>%\n  nest() %>%\n  dplyr::mutate(\n    n_comp = map_dbl(data, nrow),\n    # max_comp_pct = map_dbl(data,\n    #                        ~ max(.[\"comppct_r\"])),\n    # min_comp_pct = map_dbl(data, ~ min(.[\"comppct_r\"])),\n    cokeys = map(data, ~pull(.data = ., var = cokey))\n  ) \n```\n:::\n\n\n## Calculate map unit weighted means\n\nI use the custom function below to calculate the component percent-weighted means for all soil properties and MUKEYs.\nRecall that I have the representative component percent, `comppct_r` in the list-column \"data\" within the `cmp_nest` dataframe.\nThis came from the `cmp_lookup` table I loaded at the beginning.\n\nConveniently, we don't need to do any extra work to normalize the COKEY weights.\nThe default behavior of the `weighted.mean` function is to take the numerical vector of weights, `w`, and normalize it to sum to one.\nSo we can simply supply `comppct_r` for the weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# decided that I don't need to add \"na.rm\" argument \n# to the weighted.mean function here, because I've already removed all the NAs up above\ncalc_mu_wtd <- function(df, myvars){\n\n  wts <- df %>% pull(comppct_r)\n  \n  df_mu_wtd <- df %>%\n    summarise(across(.cols = all_of(myvars), \n                   .fns = ~weighted.mean(.x, w = wts)\n                   ))\n  \n  return(df_mu_wtd)\n\n}\n\n# test <- as.data.frame(cmp_nest$data[[115]])\n# \n# calc_mu_wtd(df = test, myvars = clust_vars)\n\n\ndf_mu_sum <- cmp_nest %>% \n  mutate(mu_sum_data = map(.x = data, \n                           .f = calc_mu_wtd,\n                           myvars = clust_vars))\n```\n:::\n\n\n## Determine data availability {#sec-dat-avail}\n\nAnother thing to think about: what is our threshold for having \"enough\" data to appropriately represent a given MUKEY?\nFor example, if we have a MUKEY represented by 1 component, but that component has a relatively small representative %?\nLike a `comppct_r` of \\<50%?\n\\<30%?\nWould we still consider that \"representative\" of that particular MUKEY?\n\nWhat Devine et al. did was use the following logic:\n\n1.  Data is available for at least 80% of the mapunit components OR\n2.  Data availability at least equal to the dominant component percentage (recall that this info is stored in the `dom_cmp_key` object for our analysis).\n\nFirst, a little context about the number of components in our remaining MUKEYs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for context, tabulate mukeys by num comps\nncomp_counts <- cmp_nest %>% \n  group_by(n_comp) %>% \n  count(name = \"n_mukeys\")\n\nhead(ncomp_counts)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"n_comp\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"n_mukeys\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"5094\"},{\"1\":\"2\",\"2\":\"1612\"},{\"1\":\"3\",\"2\":\"355\"},{\"1\":\"4\",\"2\":\"1\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow, calculate the data availability for each MUKEY.\nRecall that since we dropped incomplete cases at the COKEY level above, we can get at data availability by summing the remaining `comppct_r` for each MUKEY.\n\nThe object `dom_cmp_key` I join in here was created in back in @sec-id-comp .\nIt specifies the `comppct_r` for the dominant component in a given map unit.\nIt was important to pull this number early in our data aggregation process, before dropping any components due to missing data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_avail <- df_mu_sum %>%\n  mutate(avail_data_perc = map_dbl(data,  ~ sum(.[\"comppct_r\"]))) %>%\n  select(mukey, cokeys, avail_data_perc) %>% \n  left_join(., dom_cmp_key, by = \"mukey\")\n\n\nhead(data_avail)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukey\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"cokeys\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"avail_data_perc\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"dom_comppct\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"395973\",\"2\":\"<dbl [1]>\",\"3\":\"85\",\"4\":\"85\"},{\"1\":\"395975\",\"2\":\"<dbl [1]>\",\"3\":\"85\",\"4\":\"85\"},{\"1\":\"395900\",\"2\":\"<dbl [1]>\",\"3\":\"100\",\"4\":\"100\"},{\"1\":\"395948\",\"2\":\"<dbl [1]>\",\"3\":\"100\",\"4\":\"100\"},{\"1\":\"1146301\",\"2\":\"<dbl [1]>\",\"3\":\"15\",\"4\":\"85\"},{\"1\":\"1146306\",\"2\":\"<dbl [1]>\",\"3\":\"15\",\"4\":\"85\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Exclude based on data availability\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use same conditions as Devine et al. \n# to populate a column specifying whether \n# to include a given mukey.\n# the order of the conditions is important\n# must go from most specific to most general\n# see https://dplyr.tidyverse.org/reference/case_when.html\nexclude_key <- data_avail %>% \n  mutate(include = case_when(\n    avail_data_perc >= 80 ~ \"yes\", # cond. 2 (n=5874)\n    avail_data_perc >= dom_comppct ~ \"yes\", # cond. 1 (n=6912)\n    TRUE ~ \"no\" # doesn't meet either condition\n  )) %>% \n  select(-cokeys)\n\n# add the info about include/excl to main dataset\ndf_mu_avail <- full_join(exclude_key, df_mu_sum, by = \"mukey\")\n\n# keep only \"include\" mukeys\ndf_mu_incl <- df_mu_avail %>% \n  filter(include == \"yes\")\n```\n:::\n\n\nAfter applying the criteria above for data availability, we went from 7062 to 6912 MUKEYs, a difference of 150.\n\n## Save Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the data we want, summarised at the MUKEY level, \n# is in a list-column. That's why I use unnest here \n# before saving the results. \nmu_unnest <- df_mu_incl %>%\n  select(mukey,\n         mu_sum_data) %>%\n  unnest(mu_sum_data)\n\nwrite_csv(mu_unnest, \"./data/mu_weighted_soil_props.csv\")\n```\n:::\n\n\nAlso want to save a key that relates my included cokeys with their mukey.\nThis will be a slightly different list than the component_list.csv because we dropped COKEYs that had missing data in any of the clustering variables, and we dropped MUKEYs that didn't have sufficient data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncmp_list_incl <- df_mu_incl %>% \n  select(mukey, cokeys) %>% \n  unnest(cokeys) %>% \n  rename(cokey = cokeys)\n\nwrite_csv(cmp_list_incl, \"data/key_cokey_mukey_complete_cases_include.csv\")\n```\n:::\n\n\n## More about MUKEYs we are excluding\n\nLearn a little more about what we are excluding:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# how many MUKEYs are we excluding?\nexclude_key %>% \n  group_by(include) %>% \n  count(name = \"num_mukeys\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"include\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"num_mukeys\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"no\",\"2\":\"150\"},{\"1\":\"yes\",\"2\":\"6912\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\n# grab only mukeys we are excluding, join in more info\nmukeys_drop <- exclude_key %>% \n  filter(include == \"no\") \n\nmukeys_drop_details <- mukeys_drop %>% \n  left_join(., mukey_info, by = \"mukey\")\n\n# most of these are not prime farmland\nmukeys_drop_details %>% \n  group_by(farmlndcl) %>% \n  count()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"farmlndcl\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"n\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"All areas are prime farmland\",\"2\":\"1\"},{\"1\":\"Farmland of statewide importance\",\"2\":\"5\"},{\"1\":\"Not prime farmland\",\"2\":\"139\"},{\"1\":\"Prime farmland if drained\",\"2\":\"5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\n# types of mus \nmukeys_drop_details %>% \n  group_by(mukind) %>% \n  count()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukind\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"n\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Complex\",\"2\":\"106\"},{\"1\":\"Consociation\",\"2\":\"9\"},{\"1\":\"Undifferentiated group\",\"2\":\"35\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\n# how many acres are represented? \ndrop_acres <- sum(mukeys_drop_details$muacres)\ndrop_acres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 512769\n```\n:::\n\n```{.r .cell-code}\n# of the 150 MUKEYs, how many are urban?\nurban <- mukeys_drop_details %>% \n  filter(str_detect(muname, \"Urban\"))\n\nnrow(urban)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54\n```\n:::\n\n```{.r .cell-code}\n# and what percentage of the dropped acres are urban? \nround((sum(urban$muacres) / drop_acres) * 100, digits = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 29.1\n```\n:::\n\n```{.r .cell-code}\n# dropping urban stuff (don't care about it)\n# want to look more at the non-urban MUs\n\nmunames <- mukeys_drop_details %>% \n  filter(!str_detect(muname, \"Urban\")) %>% \n  pull(muname)\n\n# splitting at the comma so I can drop slope info\nmuname_stripped <- as.data.frame(str_split_fixed(munames, \",\", 2)) %>% select(V1)\n\n# once we strip out the slope info\n# only 35 unique, non-urban munames\ndistinct(muname_stripped) %>% \n  rename(abbrev_muname = V1) %>% \n  arrange(abbrev_muname)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"abbrev_muname\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"Berner-Markey mucks\"},{\"1\":\"Boone and Chelsea loamy fine sands\"},{\"1\":\"Bowstring and Fluaquents soils\"},{\"1\":\"Bowstring and Fluvaquents\"},{\"1\":\"Bowstring and Fluvaquents soils\"},{\"1\":\"Bowstring muck and Fluvaquents\"},{\"1\":\"Bowstring-Fluvaquents complex\"},{\"1\":\"Brainerd-Flak complex\"},{\"1\":\"Caron\"},{\"1\":\"Dumps\"},{\"1\":\"Eutrudepts-Graycalm-Rollins complex\"},{\"1\":\"Gerrish-Hapludalfs-Hegberg-Eutrudepts complex\"},{\"1\":\"Gerrish-Mahtomedi complex\"},{\"1\":\"Graycalm-Bootlake complex\"},{\"1\":\"Graycalm-Grayling complex\"},{\"1\":\"Graycalm-Grayling-Rifle complex\"},{\"1\":\"Graycalm-Grayling-Water complex\"},{\"1\":\"Graycalm-Sanburn complex\"},{\"1\":\"Graycalm-Totagatic\"},{\"1\":\"Haplosaprists\"},{\"1\":\"Klossner\"},{\"1\":\"Klossner and Lundlake soils\"},{\"1\":\"Klossner and Lura soils\"},{\"1\":\"Klossner muck\"},{\"1\":\"Klossner soils\"},{\"1\":\"Lougee-Totagatic-Bowstring complex\"},{\"1\":\"Medo muck\"},{\"1\":\"Medo soils\"},{\"1\":\"Meehan-Isan complex\"},{\"1\":\"Muskego\"},{\"1\":\"Pits\"},{\"1\":\"Prebish-Witbeck complex\"},{\"1\":\"Rock outcrop-Copaston complex\"},{\"1\":\"Rock outcrop-Ihlen complex\"},{\"1\":\"Sax\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## (old) Explore dominant component percentages {#sec-dom-eda}\n\nKeeping this here as an illustration/explanation, but the dominant component percentages we actually want to use come from @sec-id-comp .\nThis is some troubleshooting and exploration I did on the road to figuring that out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this adds MUKEY to our df \ncmp_mukey_detail <- left_join(cmp, cmp_lookup, by = c(\"cokey\"))\n\nold_dom_cmp_key <- cmp_mukey_detail %>% \n  select(cokey, mukey, comppct_r) %>% \n  group_by(mukey) %>% \n  summarise(dom_comppct = max(comppct_r))\n\nhead(old_dom_cmp_key)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukey\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"dom_comppct\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"352143\",\"2\":\"30\"},{\"1\":\"352159\",\"2\":\"90\"},{\"1\":\"352160\",\"2\":\"31\"},{\"1\":\"352162\",\"2\":\"90\"},{\"1\":\"352165\",\"2\":\"90\"},{\"1\":\"352166\",\"2\":\"50\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\n# again, these % look weird, and have some \n# very low %, because of the issues described below\nold_dom_cmp_key %>% \n  ggplot() +\n  geom_histogram(aes(x = dom_comppct)) +\n  ggtitle(\"Distribution of dominant component %\") + \n  xlab(\"Dominant component %\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](07-map-unit-agg_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThoughts after troubleshooting this.\nThe dominant component percentages shouldn't be calculated here, they should be done earlier, in @sec-id-comp, before we promote to SPC object.\nBelow is an example with two MUKEYs to illustrate.\n\nBoth of these MUKEYs have large areas in components that don't have data in the database (\"Pits\" and \"Urban Land\").\nThis makes sense.\nThese are the types of components that are dropped when we promote our `chorizon` data to an `aqp` object, see @sec-missing .\nThere is data available for lower % components \"Dassel\" and \"Udipsamment\" here, but those aren't the true dominant components, they are simply the only components that made it through the filtering that happened when I created my `aqp` object.\n\nSo if I want to use the dominant component percentage as a criterion in including/excluding data, I need to grab it earlier.\n\nMore broadly, if these areas are primarily urban land or pits, they aren't really the type of thing we'd want to include in this primarily agricultural analysis anyway.\nSo it's good that we have a way to filter them out, using similar criteria to Devine et al. (described above).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# as an example\nold_dom_cmp_key %>% \n  filter(dom_comppct < 25) %>% \n  left_join(., cmp_lookup, by = \"mukey\") %>% \n  filter(mukey %in% c(394766, 428184))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukey\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"dom_comppct\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"cokey\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"comppct_r\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"compname\"],\"name\":[5],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"compkind\"],\"name\":[6],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxclname\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxorder\"],\"name\":[8],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxsuborder\"],\"name\":[9],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxgrtgroup\"],\"name\":[10],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxsubgrp\"],\"name\":[11],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxpartsize\"],\"name\":[12],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxpartsizemod\"],\"name\":[13],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxceactcl\"],\"name\":[14],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxreaction\"],\"name\":[15],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxtempcl\"],\"name\":[16],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxmoistscl\"],\"name\":[17],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"taxtempregime\"],\"name\":[18],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"394766\",\"2\":\"20\",\"3\":\"21781218\",\"4\":\"75\",\"5\":\"Pits\",\"6\":\"Miscellaneous area\",\"7\":\"NA\",\"8\":\"NA\",\"9\":\"NA\",\"10\":\"NA\",\"11\":\"NA\",\"12\":\"NA\",\"13\":\"NA\",\"14\":\"NA\",\"15\":\"NA\",\"16\":\"NA\",\"17\":\"NA\",\"18\":\"NA\"},{\"1\":\"394766\",\"2\":\"20\",\"3\":\"21781221\",\"4\":\"20\",\"5\":\"Udipsamments\",\"6\":\"Taxon above family\",\"7\":\"Udipsamments\",\"8\":\"Entisols\",\"9\":\"Psamments\",\"10\":\"Udipsamments\",\"11\":\"NA\",\"12\":\"not used\",\"13\":\"NA\",\"14\":\"NA\",\"15\":\"not used\",\"16\":\"NA\",\"17\":\"NA\",\"18\":\"NA\"},{\"1\":\"428184\",\"2\":\"20\",\"3\":\"21787771\",\"4\":\"80\",\"5\":\"Urban land\",\"6\":\"Miscellaneous area\",\"7\":\"NA\",\"8\":\"NA\",\"9\":\"NA\",\"10\":\"NA\",\"11\":\"NA\",\"12\":\"NA\",\"13\":\"NA\",\"14\":\"NA\",\"15\":\"NA\",\"16\":\"NA\",\"17\":\"NA\",\"18\":\"NA\"},{\"1\":\"428184\",\"2\":\"20\",\"3\":\"21787772\",\"4\":\"20\",\"5\":\"Dassel\",\"6\":\"Series\",\"7\":\"Coarse-loamy, mixed, superactive, mesic Typic Endoaquolls\",\"8\":\"Mollisols\",\"9\":\"Aquolls\",\"10\":\"Endoaquolls\",\"11\":\"Typic Endoaquolls\",\"12\":\"coarse-loamy\",\"13\":\"NA\",\"14\":\"superactive\",\"15\":\"not used\",\"16\":\"mesic\",\"17\":\"NA\",\"18\":\"mesic\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n",
    "supporting": [
      "07-map-unit-agg_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}