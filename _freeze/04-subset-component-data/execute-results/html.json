{
  "hash": "53625edac6e31f8795e4e9bbf034fd90",
  "result": {
    "markdown": "# Identify Target Components {#sec-id-comp}\n\n## Setup\n\nFirst, load the list of **MUKEYs** generated in `mus_comp_in_aoi.qmd`\n\n\n::: {.cell}\n\n:::\n\n\nWe will use our MUKEYs to get the relevant components.\nI've created a list column with all the components for each MUKEY in it.\nThere are 7862 unique mapunits in my area of interest (AOI).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmn_gdb <- \"data/gSSURGO_MN/gSSURGO_MN.gdb\" \n\n# read only component table, as dataframe\nmn_comp <- sf::st_read(dsn = mn_gdb, layer = \"component\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `component' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\ntarget_comp <- mn_comp %>% \n  dplyr::filter(mukey %in% mus$mukey)\n\ncomp_nest <- target_comp %>% \n  dplyr::group_by(mukey) %>% \n  nest() %>% \n  dplyr::mutate(n_comp = map_dbl(data, nrow), \n                max_comp_pct = map_dbl(data,\n                                       ~max(.x[\"comppct_r\"])),\n                min_comp_pct = map_dbl(data, ~min(.x[\"comppct_r\"])))\n\nhead(comp_nest)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukey\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"n_comp\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_comp_pct\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_comp_pct\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1949841\",\"2\":\"<tibble[,108]>\",\"3\":\"3\",\"4\":\"85\",\"5\":\"3\"},{\"1\":\"1949850\",\"2\":\"<tibble[,108]>\",\"3\":\"4\",\"4\":\"90\",\"5\":\"3\"},{\"1\":\"2798404\",\"2\":\"<tibble[,108]>\",\"3\":\"6\",\"4\":\"75\",\"5\":\"2\"},{\"1\":\"2798405\",\"2\":\"<tibble[,108]>\",\"3\":\"7\",\"4\":\"55\",\"5\":\"1\"},{\"1\":\"2798406\",\"2\":\"<tibble[,108]>\",\"3\":\"5\",\"4\":\"75\",\"5\":\"2\"},{\"1\":\"2798407\",\"2\":\"<tibble[,108]>\",\"3\":\"4\",\"4\":\"80\",\"5\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nAfter some troubleshooting in later steps, I came back and decided it makes the most sense to **save a key of the dominant component percent** in each map unit here, before anything gets dropped in the conversion to an `aqp` object, see @sec-missing for more on this.\n\nThis is relevant because we will use the dominant component percentage (which component has highest `comppct_r` as one of our \"data sufficiency\" checks to determine if a given MUKEY is included in the clustering analysis. In doing some exploratory work in @sec-dom-eda, I noticed that we had some\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndom_cmp_key <- target_comp %>% \n  dplyr::select(cokey, mukey, comppct_r) %>% \n  dplyr::group_by(mukey) %>% \n  dplyr::summarise(dom_comppct = max(comppct_r))\n\nwrite_csv(dom_cmp_key, \"./data/key_dominant_component_percent.csv\")  \n  \n# remove b/c this is big, we are done with it\nrm(mn_comp)\n```\n:::\n\n\n## Components per mapunit\n\nOut of curiosity, what does the distribution look like for number of components in a mapunit?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-subset-component-data_files/figure-html/comp-mu-1.png){width=672}\n:::\n:::\n\n\n## Subset to components \\>15%\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_sub <- comp_nest %>%\n  dplyr::mutate(data_maj15 = map(data, ~ filter(.x, comppct_r >= 15))) %>%\n  dplyr::select(mukey, data_maj15) %>%\n  dplyr::mutate(\n    n_comp_maj = map_dbl(data_maj15, nrow),\n    max_pct = map_dbl(data_maj15,\n                           ~ max(.x[\"comppct_r\"])),\n    min_pct = map_dbl(data_maj15, ~ min(.x[\"comppct_r\"]))\n  )\n  \n\nhead(comp_sub)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mukey\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"data_maj15\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"n_comp_maj\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_pct\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_pct\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1949841\",\"2\":\"<tibble[,108]>\",\"3\":\"1\",\"4\":\"85\",\"5\":\"85\"},{\"1\":\"1949850\",\"2\":\"<tibble[,108]>\",\"3\":\"1\",\"4\":\"90\",\"5\":\"90\"},{\"1\":\"2798404\",\"2\":\"<tibble[,108]>\",\"3\":\"1\",\"4\":\"75\",\"5\":\"75\"},{\"1\":\"2798405\",\"2\":\"<tibble[,108]>\",\"3\":\"2\",\"4\":\"55\",\"5\":\"25\"},{\"1\":\"2798406\",\"2\":\"<tibble[,108]>\",\"3\":\"1\",\"4\":\"75\",\"5\":\"75\"},{\"1\":\"2798407\",\"2\":\"<tibble[,108]>\",\"3\":\"1\",\"4\":\"80\",\"5\":\"80\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow how many **major** components are we working with per map unit?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-subset-component-data_files/figure-html/nmaj-comp-1.png){width=672}\n:::\n:::\n\n\nI'm saving this simple list of map units and number of components, max component percent for a later step where we determine if there is enough data to include that map unit in our final analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmajor_mu_summary <- comp_sub %>% \n  dplyr::select(mukey, n_comp_maj, max_pct, min_pct)\n\nwrite_csv(major_mu_summary, \"./data/mu_summary_maj_only.csv\")\n```\n:::\n\n\n## Identify unique components\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_unnest <- comp_sub %>% \n  dplyr::select(data_maj15, mukey) %>% \n  tidyr::unnest(cols = c(data_maj15))\n\nwrite_csv(comp_unnest, \"./data/component_list.csv\")\n```\n:::\n\n\nI have 7862 unique MUKEYs and 10785 and unique COKEYs.\nIt appears that there are no repeated COKEYs shared between mapunits.\n\n## Pull Horizon Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# most of the soil property data we want is in the\n# chorizon table, om, pH, clay, etc.\nchoriz <- sf::st_read(dsn = mn_gdb, layer = \"chorizon\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `chorizon' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\ntarget_choriz <- choriz %>% \n  dplyr::filter(cokey %in% comp_unnest$cokey)\n```\n:::\n\n\n## Coarse Fragments\n\n-   Need to pull `fragvol_r` from the `chfrags` table, this is the volume percentage of horizon occupied by 2mm or larger fraction (20mm or larger for wood fragments) on a whole soil basis\n-   Turns out I need to aggregate this by `chkey`, there can be multiple `fragvol_r` entries for a given component-horizon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# some coarse frag data in the chfrag table\nchfrag <- sf::st_read(dsn = mn_gdb, layer = \"chfrags\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `chfrags' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\n# keep only the component horizons I'm interested in\ntarget_chfrag <-  chfrag %>% \n  dplyr::filter(chkey %in% target_choriz$chkey)\n\n# sum volume of coarse frags in a given horizon\nfrag_hz_summary <- target_chfrag %>% \n  dplyr::group_by(chkey) %>% \n  dplyr::summarise(fragvol_r_sum = sum(fragvol_r, na.rm = TRUE),\n            .groups = \"drop\") %>% \n  dplyr::select(chkey, fragvol_r_sum) \n\n# add coarse frag col to my df\ntarget_choriz_frag <- left_join(target_choriz, frag_hz_summary, by = \"chkey\")\n```\n:::\n\n\n## Save Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(target_choriz_frag, \"data/target_choriz_all.csv\")\n```\n:::\n",
    "supporting": [
      "04-subset-component-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}