{
  "hash": "53625edac6e31f8795e4e9bbf034fd90",
  "result": {
    "markdown": "# Identify Target Components {#sec-id-comp}\n\n## Setup\n\nFirst, load the list of **MUKEYs** generated in `mus_comp_in_aoi.qmd`\n\n\n\n::: {.cell}\n\n:::\n\n\n\nWe will use our MUKEYs to get the relevant components.\nI've created a list column with all the components for each MUKEY in it.\nThere are 7862 unique mapunits in my area of interest (AOI).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmn_gdb <- \"data/gSSURGO_MN/gSSURGO_MN.gdb\" \n\n# read only component table, as dataframe\nmn_comp <- sf::st_read(dsn = mn_gdb, layer = \"component\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `component' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\ntarget_comp <- mn_comp %>% \n  dplyr::filter(mukey %in% mus$mukey)\n\ncomp_nest <- target_comp %>% \n  dplyr::group_by(mukey) %>% \n  nest() %>% \n  dplyr::mutate(n_comp = map_dbl(data, nrow), \n                max_comp_pct = map_dbl(data,\n                                       ~max(.x[\"comppct_r\"])),\n                min_comp_pct = map_dbl(data, ~min(.x[\"comppct_r\"])))\n\nhead(comp_nest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n# Groups:   mukey [6]\n  mukey   data               n_comp max_comp_pct min_comp_pct\n  <chr>   <list>              <dbl>        <dbl>        <dbl>\n1 1949841 <tibble [3 x 108]>      3           85            3\n2 1949850 <tibble [4 x 108]>      4           90            3\n3 2798404 <tibble [6 x 108]>      6           75            2\n4 2798405 <tibble [7 x 108]>      7           55            1\n5 2798406 <tibble [5 x 108]>      5           75            2\n6 2798407 <tibble [4 x 108]>      4           80            3\n```\n:::\n:::\n\n\n\nAfter some troubleshooting in later steps, I came back and decided it makes the most sense to **save a key of the dominant component percent** in each map unit here, before anything gets dropped in the conversion to an `aqp` object, see @sec-missing for more on this.\n\nThis is relevant because we will use the dominant component percentage (which component has highest `comppct_r` as one of our \"data sufficiency\" checks to determine if a given MUKEY is included in the clustering analysis. In doing some exploratory work in @sec-dom-eda, I noticed that we had some\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndom_cmp_key <- target_comp %>% \n  dplyr::select(cokey, mukey, comppct_r) %>% \n  dplyr::group_by(mukey) %>% \n  dplyr::summarise(dom_comppct = max(comppct_r))\n\nwrite_csv(dom_cmp_key, \"./data/key_dominant_component_percent.csv\")  \n  \n# remove b/c this is big, we are done with it\nrm(mn_comp)\n```\n:::\n\n\n\n## Components per mapunit\n\nOut of curiosity, what does the distribution look like for number of components in a mapunit?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-subset-component-data_files/figure-pdf/comp-mu-1.pdf)\n:::\n:::\n\n\n\n## Subset to components \\>15%\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_sub <- comp_nest %>%\n  dplyr::mutate(data_maj15 = map(data, ~ filter(.x, comppct_r >= 15))) %>%\n  dplyr::select(mukey, data_maj15) %>%\n  dplyr::mutate(\n    n_comp_maj = map_dbl(data_maj15, nrow),\n    max_pct = map_dbl(data_maj15,\n                           ~ max(.x[\"comppct_r\"])),\n    min_pct = map_dbl(data_maj15, ~ min(.x[\"comppct_r\"]))\n  )\n  \n\nhead(comp_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n# Groups:   mukey [6]\n  mukey   data_maj15         n_comp_maj max_pct min_pct\n  <chr>   <list>                  <dbl>   <dbl>   <dbl>\n1 1949841 <tibble [1 x 108]>          1      85      85\n2 1949850 <tibble [1 x 108]>          1      90      90\n3 2798404 <tibble [1 x 108]>          1      75      75\n4 2798405 <tibble [2 x 108]>          2      55      25\n5 2798406 <tibble [1 x 108]>          1      75      75\n6 2798407 <tibble [1 x 108]>          1      80      80\n```\n:::\n:::\n\n\n\nNow how many **major** components are we working with per map unit?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-subset-component-data_files/figure-pdf/nmaj-comp-1.pdf)\n:::\n:::\n\n\n\nI'm saving this simple list of map units and number of components, max component percent for a later step where we determine if there is enough data to include that map unit in our final analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmajor_mu_summary <- comp_sub %>% \n  dplyr::select(mukey, n_comp_maj, max_pct, min_pct)\n\nwrite_csv(major_mu_summary, \"./data/mu_summary_maj_only.csv\")\n```\n:::\n\n\n\n## Identify unique components\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_unnest <- comp_sub %>% \n  dplyr::select(data_maj15, mukey) %>% \n  tidyr::unnest(cols = c(data_maj15))\n\nwrite_csv(comp_unnest, \"./data/component_list.csv\")\n```\n:::\n\n\n\nI have 7862 unique MUKEYs and 10785 and unique COKEYs.\nIt appears that there are no repeated COKEYs shared between mapunits.\n\n## Pull Horizon Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# most of the soil property data we want is in the\n# chorizon table, om, pH, clay, etc.\nchoriz <- sf::st_read(dsn = mn_gdb, layer = \"chorizon\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `chorizon' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\ntarget_choriz <- choriz %>% \n  dplyr::filter(cokey %in% comp_unnest$cokey)\n```\n:::\n\n\n\n## Coarse Fragments\n\n-   Need to pull `fragvol_r` from the `chfrags` table, this is the volume percentage of horizon occupied by 2mm or larger fraction (20mm or larger for wood fragments) on a whole soil basis\n-   Turns out I need to aggregate this by `chkey`, there can be multiple `fragvol_r` entries for a given component-horizon.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# some coarse frag data in the chfrag table\nchfrag <- sf::st_read(dsn = mn_gdb, layer = \"chfrags\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `chfrags' from data source \n  `C:\\Users\\Hava\\Documents\\R\\ch03-sh-cluster\\data\\gSSURGO_MN\\gSSURGO_MN.gdb' \n  using driver `OpenFileGDB'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n```\n:::\n\n```{.r .cell-code}\n# keep only the component horizons I'm interested in\ntarget_chfrag <-  chfrag %>% \n  dplyr::filter(chkey %in% target_choriz$chkey)\n\n# sum volume of coarse frags in a given horizon\nfrag_hz_summary <- target_chfrag %>% \n  dplyr::group_by(chkey) %>% \n  dplyr::summarise(fragvol_r_sum = sum(fragvol_r, na.rm = TRUE),\n            .groups = \"drop\") %>% \n  dplyr::select(chkey, fragvol_r_sum) \n\n# add coarse frag col to my df\ntarget_choriz_frag <- left_join(target_choriz, frag_hz_summary, by = \"chkey\")\n```\n:::\n\n\n\n## Save Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(target_choriz_frag, \"data/target_choriz_all.csv\")\n```\n:::\n",
    "supporting": [
      "04-subset-component-data_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}